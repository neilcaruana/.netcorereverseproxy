using Microsoft.Data.Sqlite;
using ReverseProxyServer.Data.Sqlite;
using System.ComponentModel.Design;
using System.Reflection;
using System.Reflection.PortableExecutable;
using static Microsoft.EntityFrameworkCore.DbLoggerCategory.Database;

namespace ReverseProxyServer.Repositories
{
    public class GenericSqliteRepository<T> : SqlLiteDataLayer, IGenericRepository<T> where T : new()
    {
        public GenericSqliteRepository(string databasePath) : base(databasePath)
        {
        }
        public async Task<T?> GetByPrimaryKeyAsync(object pkValue)
        {
            if (pkValue == null)
                throw new Exception("PK value must be specified");

            TableMetaData meta = MetadataCache.GetTableMetadata<T>();
            List<T> data = await getListDataByFieldAsync(meta.PrimaryKey,pkValue);
            return data.FirstOrDefault();
        }
        public async Task<T?> GetByFieldValueAsync(string fieldName, object fieldValue)
        {
            if (string.IsNullOrWhiteSpace(fieldName))
                throw new Exception("Field name must be specified");

            if (fieldValue == null)
                throw new Exception("Field value must be specified");

            List<T> data = await getListDataByFieldAsync(fieldName, fieldValue);
            return data.FirstOrDefault();
        }
        public async Task<List<T>> GetListDataByFieldValueAsync(string fieldName = "", object? fieldValue = null)
        {
            return await getListDataByFieldAsync(fieldName, fieldValue);
        }
        public async Task<T> InsertAsync(T entity)
        {
            using SqliteConnection connection = await base.GetOpenConnection();
            using SqliteTransaction transaction = connection.BeginTransaction();

            TableMetaData meta = MetadataCache.GetTableMetadata<T>();
            using SqliteCommand command = new(meta.InsertQuery, connection, transaction);

            base.InjectCommandWithParameters(command, meta.InsertQuery, meta.Columns, entity);
            object? dbEntity = await command.ExecuteScalarAsync();

            //Update of database Identity primary key to entity
            if (meta.IsPrimaryKeyIdentity)
            {
                if (meta.PrimaryKeyProp.CanWrite)
                    meta.PrimaryKeyProp.SetValue(entity, Convert.ChangeType(dbEntity, meta.PrimaryKeyProp.PropertyType));
                else
                    throw new Exception($"Entity [{meta.TableName}] primary key property [{meta.PrimaryKey}] is read only and cannot be updated");
            }

            //Update entity with other database generated columns that are not a primary key
            var nonPkAutoGeneratedColumns = meta.DatabaseAutoGeneratedColumns.Where(c => c.Key.Name != meta.PrimaryKey);
            if (nonPkAutoGeneratedColumns.Any())
            {
                //Read primary key value from DB if auto generated identity or from entity if not
                object? pkValue = dbEntity != null ? meta.PrimaryKeyProp.GetValue(dbEntity) : meta.PrimaryKeyProp.GetValue(entity);
                using SqliteCommand refreshCommand = new(meta.SelectQuery + $" WHERE {meta.PrimaryKey} = @{meta.PrimaryKey}", connection, transaction);
                refreshCommand.Parameters.AddWithValue($"@{meta.PrimaryKey}", pkValue);

                //Read database with refreshed record and update entity
                using SqliteDataReader reader = await refreshCommand.ExecuteReaderAsync();
                if (!reader.Read())
                    throw new Exception($"Not data found in table [{meta.TableName}] for primary key value [{pkValue}]");

                T? updateEntity = base.MapSqliteReaderToEntity<T>(reader, meta.Columns);
                //Loop only db generated columns and update entity from DB
                foreach (PropertyInfo autoGenProperty in nonPkAutoGeneratedColumns.Select(c => c.Key))
                {
                    if (autoGenProperty != null && autoGenProperty.CanWrite)
                        autoGenProperty.SetValue(entity, autoGenProperty.GetValue(updateEntity));
                    else
                        throw new Exception($"Entity [{meta.TableName}] property [{autoGenProperty?.Name}] is read only/not found and cannot be updated");
                }
            }

            await transaction.CommitAsync();
            return entity;
        }
        public async Task<T> UpsertAsync(T entity)
        {
            int rowsAffected = await this.UpdateAsync(entity);
            if (rowsAffected > 0)
                return await this.InsertAsync(entity);

            //Record already existed in DB return updated record
            return await this.GetByPrimaryKeyAsync(entity) ?? throw new Exception("Record not found after upsert!");
        }
        public async Task<int> UpdateAsync(T entity)    
        {
            TableMetaData meta = MetadataCache.GetTableMetadata<T>();
            using SqliteCommand command = new(meta.UpdateQuery, await base.GetOpenConnection());
            base.InjectCommandWithParameters(command, meta.UpdateQuery, meta.Columns, entity);

            return await command.ExecuteNonQueryAsync();
        }
        public async Task<int> DeleteAsync(T entity)
        {
            TableMetaData meta = MetadataCache.GetTableMetadata<T>();
            using SqliteCommand command = new(meta.DeleteQuery, await base.GetOpenConnection());
            base.InjectCommandWithParameters(command, meta.DeleteQuery, meta.Columns, entity);

            return await command.ExecuteNonQueryAsync();
        }
        public async Task<long> CountAsync()
        {
            TableMetaData meta = MetadataCache.GetTableMetadata<T>();
            using SqliteCommand command = new($"SELECT Count(*) From {meta.TableName}", await base.GetOpenConnection());

            return Convert.ToInt64(await command.ExecuteScalarAsync());
        }
        public async Task<bool> AnyAsync()
        {
            TableMetaData meta = MetadataCache.GetTableMetadata<T>();
            using SqliteCommand command = new($"SELECT {meta.PrimaryKey} From {meta.TableName} LIMIT 1", await base.GetOpenConnection());

            return await command.ExecuteScalarAsync() != null;
        }
        private async Task<List<T>> getListDataByFieldAsync(string fieldName = "", object? fieldValue = null)
        {
            if (!string.IsNullOrWhiteSpace(fieldName) && fieldValue == null)
                throw new Exception("Both field name and value must be specified");

            TableMetaData meta = MetadataCache.GetTableMetadata<T>();

            using SqliteConnection connection = await GetOpenConnection();
            string selectQuery = meta.SelectQuery + (!string.IsNullOrWhiteSpace(fieldName) ? $" WHERE {fieldName} = @{fieldName}" : "");
            using SqliteCommand command = new(selectQuery, connection);
            command.Parameters.AddWithValue($"@{fieldName}", fieldValue);

            using SqliteDataReader reader = await command.ExecuteReaderAsync();
            if (!reader.Read())
                return [];

            List<T> data = [];
            do
            {//First record already read map data and read next
                data.Add(base.MapSqliteReaderToEntity<T>(reader, meta.Columns));

            } while (reader.Read());

            return data;
        }

    }
}
